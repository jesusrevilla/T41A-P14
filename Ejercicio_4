-- --- Preparación: Crear la tabla de auditoría ---
DROP TABLE IF EXISTS auditoria_productos;
CREATE TABLE auditoria_productos (
    id SERIAL PRIMARY KEY,
    producto_id INT NOT NULL,
    precio_anterior NUMERIC,
    precio_nuevo NUMERIC,
    fecha_modificacion TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW()
);

-- 4_Modificar un procedimiento para registrar en una tabla de auditoría cada vez que se actualiza un producto.
CREATE OR REPLACE PROCEDURE actualizar_precio_con_auditoria(
    IN p_id INT,
    IN p_nuevo_precio NUMERIC
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_precio_anterior NUMERIC;
BEGIN
    -- 1. Verificar el precio actual y si el producto existe.
    SELECT precio INTO v_precio_anterior
    FROM productos
    WHERE id = p_id;

    -- 2. Control de Flujo (Similar al Ejemplo 3)
    IF v_precio_anterior IS NULL THEN
        RAISE NOTICE 'El producto con ID % no existe.', p_id;
    ELSIF p_nuevo_precio <= 0 THEN
        RAISE NOTICE 'El precio debe ser mayor que cero.';
    ELSE
        -- 3. Iniciar Transacción explícita (Buena práctica para operaciones con 2+ DML)
        BEGIN
            -- 3a. Realizar la actualización
            UPDATE productos
            SET precio = p_nuevo_precio
            WHERE id = p_id;

            -- 3b. Registrar la auditoría
            INSERT INTO auditoria_productos (producto_id, precio_anterior, precio_nuevo)
            VALUES (p_id, v_precio_anterior, p_nuevo_precio);

            -- 3c. Confirmar la transacción
            -- COMMIT; -- El plpgsql maneja el COMMIT implícito si no hay error

            RAISE NOTICE 'Producto ID % actualizado de % a %. Auditoría registrada.', p_id, v_precio_anterior, p_nuevo_precio;

        EXCEPTION
            WHEN OTHERS THEN
                -- Si hay un error en UPDATE o INSERT, se hará ROLLBACK
                RAISE NOTICE 'Error en la transacción de actualización y auditoría: %', SQLERRM;
        END;
    END IF;
END;
$$;
